{"version":3,"sources":["exo_icon/src/scss/exo.icon.admin.scss","../../Sites/augustAsh/msep/web/modules/contrib/exo/exo/src/scss/util/_grid.scss","../../Sites/augustAsh/msep/web/modules/contrib/exo/exo/src/scss/util/_breakpoint.scss"],"names":[],"mappings":"AAEA,eCmKE,YAAA,CACA,kBAAA,CAnDI,qBAAA,CAAA,uBAAA,CAAA,wBAAA,CAAA,sBAAA,CD5GJ,cAAA,CACA,oBAAA,CAEA,SAAA,CACA,iBAAA,CAEA,kBCkPE,4BADM,CA3IJ,sBAAA,CAAA,wBAAA,CAAA,yBAAA,CAAA,uBAAA,CDpGF,kBAAA,CAEA,gBAAA,CACA,wBAAA,CACA,qBAAA,CAEA,sBACE,eAAA,CE2IA,0CFpJJ,kBCkPE,uCADM,CA3IJ,sBAAA,CAAA,wBAAA,CAAA,yBAAA,CAAA,uBAAA,CAAA,CDrFJ,yBACE,aAAA,CACA,gBAAA,CACA,kBAAA,CAEA,gCACE,aAAA,CAIJ,+BACE,aAAA,CAGF,0BACE,QAAA,CAKA,+BACE,aAAA,CACA,iBAAA,CACA,UAAA,CACA,YAAA,CACA,qBAAA,CACA,QAAA,CACA,eAAA,CACA,eAAA,CACA,iBAAA,CAIJ,qBACE,iBAAA,CAGF,oBACE,aAAA,CAMF,0BACE,cAAA","file":"exo.icon.admin.css","sourcesContent":["@import 'exo-common';\n\n.exo-icon-list {\n  @include exo-grid;\n  @include exo-gutters($gutters: 1px, $gutter-position: top right bottom left);\n  // @include flex;\n  // @include flex-align(justify, middle);\n  flex-wrap: wrap;\n  list-style-type: none;\n  // margin: 0;\n  padding: 0;\n  text-align: center;\n\n  > li {\n    @include exo-cell(6, $gutters: -1px, $gutter-position: top right bottom left);\n    background: color(theme-offset);\n    // max-width: rem-calc(120);\n    padding: size(padding) * 0.5;\n    border: 1px solid color(theme-base);\n    box-sizing: border-box;\n\n    > div {\n      margin-bottom: 0;\n    }\n\n    @include breakpoint(large) {\n      @include exo-cell(2, $gutters: -1px, $gutter-position: top right bottom left);\n    }\n  }\n\n  .exo-icon {\n    display: block;\n    font-size: rem-calc(40);\n    line-height: rem-calc(40);\n\n    &:before {\n      color: color(theme-black);\n    }\n  }\n\n  .exo-icon-image {\n    margin: 0 auto;\n  }\n\n  .form-item {\n    margin: 0;\n  }\n\n  input {\n\n    &.form-text {\n      display: block;\n      text-align: center;\n      width: 100%;\n      margin: 0 4px;\n      box-sizing: border-box;\n      border: 0;\n      border-radius: 0;\n      box-shadow: none;\n      font-size: rem-calc(10);\n    }\n  }\n\n  .info {\n    font-style: italic;\n  }\n\n  .svg {\n    color: color(theme-black);\n  }\n}\n\n.exo-icon-table {\n\n  .exo-icon {\n    font-size: rem-calc(16);\n  }\n}\n","@use \"sass:math\";\n\n/////////////////////\n// Exo Grid\n// ---------\n\n/////////////////////\n// Exo Grid Settings\n// ---------\n\n/// Enables the Exo-exo grid.\n/// @type Boolean\n$exo-grid: true !default;\n\n/// The maximum width of a grid container.\n/// @type Number\n$grid-container: $global-width !default;\n\n/// The number of columns used in the grid.\n/// @type Number\n$grid-columns: 12 !default;\n\n/// The amount of margin between cells at different screen sizes when using the margin grid. To use just one size, set the variable to a number instead of a map.\n/// @type Map | Length\n$grid-margin-gutters: $global-margin * 2 !default;\n\n/// The amount of padding in cells at different screen sizes when using the padding grid. To use just one size, set the variable to a number instead of a map.\n/// @type Map | Length\n$grid-padding-gutters: $grid-margin-gutters !default;\n\n/// The amount of padding to use when padding the grid-container.\n/// @type Map | Length\n$grid-container-padding: $grid-padding-gutters !default;\n\n/// The maximum width to apply to a grid container\n/// @type Number\n$grid-container-max: $global-width !default;\n\n/// The maximum number of cells in an Exo block grid.\n/// @type Number\n$exo-block-grid-max: 8 !default;\n\n/////////////////////\n// Exo Grid - Gutters\n// ---------\n\n/// Calculate gutter size.\n///\n/// @param {List} $gutter-position [right left] - The position to apply gutters to. Accepts `top`, `bottom`, `left`, `right` in any combination.\n/// @param {Boolean} $gutter-output [true] - Whether or not to output gutters\n/// @param {Number|Map} $gutters [$grid-margin-gutters] - Map or single value for gutters.\n/// @param {Keyword} $gutter-type [margin] - Map or single value for gutters.\n/// @param {String} $breakpoint [null] - The name of the breakpoint size in your gutters map to get the size from. If using with the `breakpoint()` mixin this will be set automatically unless manually entered.\n@function exo-gutters-value(\n  $gutter-position: right left,\n  $gutter-type: margin,\n  $gutters: $grid-margin-gutters,\n  $breakpoint: null\n) {\n  $bp-is-fallback: false;\n\n  @if ($breakpoint == null) {\n    // If `$bp-size` is available then use this, otherwise revert to the smallest bp.\n    @if(variable-exists(-exo-size) and type-of($-exo-size) != 'number') and $-exo-size != null {\n      $breakpoint: $-exo-size;\n    }\n    @else {\n      $breakpoint: $-exo-zero-breakpoint;\n      $bp-is-fallback: true;\n    }\n  }\n\n  // Get the gutter for the given breakpoint/value.\n  $gutter: -exo-get-bp-val($gutters, $breakpoint);\n  // If the breakpoint is a fallback, use a fallback gutter as well\n  @if ($bp-is-fallback == true and $gutter == null) {\n    $gutter: 0;\n  }\n\n  @return $gutter;\n}\n\n/// Create gutters for a cell/container.\n///\n/// @param {Number|Map} $gutters [$grid-margin-gutters] - Map or single value for gutters.\n/// @param {Keyword} $gutter-type [margin] - Type of gutter to output. Accepts either margin or padding.\n/// @param {List} $gutter-position [right left] - The position to apply gutters to. Accepts `top`, `bottom`, `left`, `right` in any combination.\n/// @param {Boolean} $negative [false] - Whether to apply the gutter as a negative value. Commonly used for nested grids.\n@mixin exo-gutters-set(\n  $gutters: $grid-margin-gutters,\n  $gutter-type: margin,\n  $gutter-position: right left,\n  $negative: false\n) {\n  $operator: if($negative, '-', '');\n\n  // If we have declared negative gutters, force type to `margin.\n  $gutter-type: if($negative, 'margin', $gutter-type);\n\n  // Output our margin gutters.\n  @if (type-of($gutters) == 'map') {\n    @include -exo-breakpoint-value(auto, $gutters) {\n      $gutter: rem-calc($-exo-bp-value) * 0.5;\n\n      // Loop through each gutter position\n      @each $value in $gutter-position {\n        #{$gutter-type}-#{$value}: unquote('#{$operator}#{$gutter}');\n      }\n    }\n  }\n  @else if (type-of($gutters) == 'number') {\n    $gutter: math.div(rem-calc($gutters), 2);\n\n    // Loop through each gutter position\n    @each $value in $gutter-position {\n      #{$gutter-type}-#{$value}: unquote(\"#{$operator}#{$gutter}\");\n    }\n  }\n}\n\n/////////////////////\n// Exo Grid - Grid\n// ---------\n\n/// Creates a max width container, designed to house your grid content.\n///\n/// @param {Number} $width [$grid-container] - a width to limit the container to.\n/// @param {Number} $padding [$grid-container-padding] - paddings of the container.\n@mixin exo-grid-container(\n  $width: $grid-container,\n  $padding: $grid-container-padding\n) {\n  @include exo-gutters-set($gutters: $padding, $gutter-type: padding);\n\n  max-width: $width;\n  margin: 0 auto;\n}\n\n/////////////////////\n// Exo Grid - Nested Grid\n// ---------\n/// Creates a nested grid container, designed to house your grid content.\n///\n/// @param {Number} $width [$grid-container] - a width to limit the container to.\n/// @param {Number} $padding [$grid-container-padding] - paddings of the container.\n@mixin exo-grid-container-nested(\n  $width: $grid-container,\n  $padding: $grid-container-padding\n) {\n  @include exo-gutters-set($gutters: $padding, $gutter-type: margin, $gutter-position: left right, $negative: true);\n\n  max-width: $width;\n}\n\n/// Creates a container for your flex cells.\n///\n/// @param {Keyword} $direction [horizontal] - Either horizontal or vertical direction of cells within.\n/// @param {Boolean} $wrap [true] - If the cells within should wrap or not.\n@mixin exo-grid(\n  $direction: horizontal,\n  $wrap: true\n) {\n  $direction: if($direction == 'horizontal', row, column);\n  $wrap: if($wrap, wrap, nowrap);\n\n  display: flex;\n  flex-flow: $direction $wrap;\n}\n\n/////////////////////\n// Exo Grid - Cell\n// ---------\n\n/// Calculate the percentage size of a cell.\n///\n/// @param {Number|List} $size [$grid-columns] - Size to make the cell. You can pass a value in multiple formats, such as `6`, `50%`, `1 of 2` or `1/3`.\n@function exo-cell-size(\n  $size: $grid-columns\n) {\n  // Parsing percents, decimals, n of n and number counts\n  @if type-of($size) == 'number' {\n    @if unit($size) == '%' {\n      $size: $size;\n    }\n    @else if $size < 1 {\n      $size: percentage($size);\n    }\n    @else {\n      $size: percentage(math.div($size, $grid-columns));\n    }\n  }\n\n  // Parsing \"n of n\" or \"n/n\" expressions\n  @else if type-of($size) == 'list' {\n    @if length($size) != 3 {\n      @error 'Wrong syntax for exo-cell-size(). Use the format \"n of n\" or \"n/n\".';\n    }\n    @else {\n      $size: percentage(math.div(nth($size, 1), nth($size, 3)));\n    }\n  }\n  // Anything else is incorrect\n  @else {\n    @error 'Wrong syntax for exo-cell-size(). Use a number, decimal, percentage, or \"n of n\" / \"n/n\".';\n  }\n\n  @return $size;\n}\n\n/// Sets base flex properties for cells.\n///\n/// @param {Keyword} $size [full] - The size of your cell. Accepts `full`, `auto`, `shrink` or `grow`.\n@mixin exo-cell-base($size: full) {\n  @if($size == 'full') {\n    // This is the base style, all others inherit from it\n    flex: 0 0 auto;\n    min-height: 0px; // sass-lint:disable-line zero-unit\n    min-width: 0px; // sass-lint:disable-line zero-unit\n  }\n  @else if ($size == 'auto') {\n    flex: 1 1 0px; // sass-lint:disable-line zero-unit\n  }\n  @else if ($size == 'shrink') {\n    flex: 0 0 auto;\n  }\n  @else if ($size == 'grow') {\n    flex: 1 0 auto;\n  }\n}\n\n/// Resets a cells width (or height if vertical is true) as well as strips its gutters.\n///\n/// @param {Boolean} $vertical [false] - Set to true to output vertical (height) styles rather than widths.\n@mixin exo-cell-reset($vertical: true) {\n  $direction: if($vertical == true, width, height);\n  #{$direction}: auto;\n  max-#{$direction}: none;\n}\n\n// Sets our cell widths or heights depending on gutter type.\n@mixin -exo-cell-properties($size, $margin-gutter, $vertical) {\n  $direction: if($vertical == true, height, width);\n  @if($size == 'full') {\n    $val: if($margin-gutter == 0, 100%, calc(100% - #{rem-calc($margin-gutter)}));\n    #{$direction}: $val;\n  }\n  @else if ($size == 'auto') {\n    #{$direction}: auto;\n    $val: if($margin-gutter == 0, 100%, calc(100% - #{rem-calc($margin-gutter)}));\n  }\n  @else if ($size == 'shrink') {\n    #{$direction}: auto;\n  }\n  @else {\n    $val: if($margin-gutter == 0, #{exo-cell-size($size)}, calc(#{exo-cell-size($size)} - #{rem-calc($margin-gutter)}));\n    #{$direction}: $val;\n  }\n}\n\n/// Creates a cell for your grid.\n///\n/// @param {Keyword|Number} $size [full] - The size of your cell. Can be `full` (default) for 100% width, `auto` to use up available space and `shrink` to use up only required space.\n/// @param {List} $gutter-position [right left] - The position to apply gutters to. Accepts `top`, `bottom`, `left`, `right` in any combination.\n/// @param {Boolean} $gutter-output [true] - Whether or not to output gutters\n/// @param {Number|Map} $gutters [$grid-margin-gutters] - Map or single value for gutters.\n/// @param {Keyword} $gutter-type [margin] - Map or single value for gutters.\n/// @param {String} $breakpoint [null] - The name of the breakpoint size in your gutters map to get the size from. If using with the `breakpoint()` mixin this will be set automatically unless manually entered.\n/// @param {Boolean} $vertical [false] - Set to true to output vertical (height) styles rather than widths.\n@mixin exo-cell(\n  $size: full,\n  $gutter-position: right left,\n  $gutter-type: margin,\n  $gutter-output: true,\n  $gutters: $grid-margin-gutters,\n  $breakpoint: null,\n  $vertical: false\n) {\n  $gutter: exo-gutters-value($gutter-position, $gutter-type, $gutters, $breakpoint);\n  @if($gutter != null) {\n    // Base flex properties\n    @include exo-cell-base($size);\n\n    @if($gutter-type == 'margin') {\n      @include -exo-cell-properties($size, $gutter, $vertical);\n    }\n    @else {\n      @include -exo-cell-properties($size, 0, $vertical);\n    }\n\n    @if $gutter-output {\n      @include exo-gutters-set($gutter, $gutter-type, $gutter-position);\n    }\n  }\n  @else {\n    @warn 'exo-cell: no gutters were found in `$gutters` for \"$breakpoint: {$breakpoint}\", cell was not generated`';\n  }\n}\n\n@mixin exo-gutters(\n  $gutter-position: right left,\n  $gutter-type: margin,\n  $gutters: $grid-margin-gutters,\n  $breakpoint: null,\n  $negative: false\n) {\n  $gutter: exo-gutters-value($gutter-position, $gutter-type, $gutters, $breakpoint);\n  @include exo-gutters-set($gutter, $gutter-type, $gutter-position, $negative);\n}\n\n/// Creates a single breakpoint sized grid. Used to generate our grid classes.\n///\n/// @param {Keyword|Number} $size [full] - The size of your cell. Can be `full` (default) for 100% width, `auto` to use up available space and `shrink` to use up only required space.\n/// @param {Boolean} $gutter-output [true] - Whether or not to output gutters\n/// @param {Number|Map} $gutters [$grid-margin-gutters] - Map or single value for gutters.\n/// @param {Keyword} $gutter-type [margin] - Map or single value for gutters.\n/// @param {String} $breakpoint [null] - The name of the breakpoint size in your gutters map to get the size from. If using with the `breakpoint()` mixin this will be set automatically unless manually entered.\n/// @param {Boolean} $vertical [false] - Set to true to output vertical (height) styles rather than widths.\n@mixin exo-cell-static(\n  $size: full,\n  $gutter-output: true,\n  $gutters: $grid-margin-gutters,\n  $gutter-type: margin,\n  $breakpoint: $-exo-zero-breakpoint,\n  $vertical: false\n) {\n\n  $gutter: -exo-get-bp-val($gutters, $breakpoint);\n  $gutter-position: if($vertical == true, top bottom, left right);\n\n  @if($gutter-type == 'margin') {\n    @include -exo-cell-properties($size, $gutter, $vertical);\n  }\n  @else {\n    @include -exo-cell-properties($size, 0, $vertical);\n  }\n\n  // If we want to output the gutters\n  @if($gutter-output) {\n    // TODO: Figure out if we need to pass breakpoint in here too.\n    @include exo-gutters-set($gutter, $gutter-type, $gutter-position);\n  }\n}\n\n/////////////////////\n// Exo Grid - Frame\n// ---------\n\n/// Modifies a grid to give it \"frame\" behavior (no overflow, no wrap, stretch behavior)\n///\n/// @param {Boolean} $vertical [false] - Is grid vertical or horizontal. Should match grid.\n/// @param {Boolean} $nested [false] - Is grid nested or not. If nested is true this sets the frame to 100% height, otherwise will be 100vh.\n/// @param {Number|Map} $gutters [null] - Map or single value for gutters.\n/// @param {String} $breakpoint [null] - The name of the breakpoint size in your gutters map to get the size from.\n/// @param {Boolean} $include-base [true] - Include the base styles that don't vary per breakpoint.\n@mixin exo-grid-frame(\n  $vertical: false,\n  $nested: false,\n  $gutters: null,\n  $breakpoint: null,\n  $include-base: true\n) {\n\n  @if $include-base {\n    overflow: hidden;\n    position: relative;\n    flex-wrap: nowrap;\n    align-items: stretch;\n  }\n\n  @if $breakpoint == null and type-of($gutters) == 'map' {\n    @include -exo-each-breakpoint() {\n      @include exo-grid-frame($vertical, $nested, $gutters, $-exo-size, false);\n    }\n  } @else {\n    // Get our gutters if applicable\n    $gutter: -exo-get-bp-val($gutters, $breakpoint);\n\n    // If we have a gutter, add it to the width/height\n    @if $gutter {\n      @if $vertical == true {\n        $unit: if($nested == true, 100%, 100vh);\n        $gutter: rem-calc($gutter);\n        height: calc(#{$unit} + #{$gutter});\n      } @else {\n        $unit: if($nested == true, 100%, 100vw);\n        $gutter: rem-calc($gutter);\n        width: calc(#{$unit} + #{$gutter});\n      }\n    }\n    @else {\n      @if $vertical == true {\n        height: if($nested == true, 100%, 100vh);\n      } @else {\n        width: if($nested == true, 100%, 100vw);\n      }\n    }\n  }\n}\n\n/// Modifies a cell to give it \"block\" behavior (overflow auto, inertial scrolling)\n///\n/// @param {Boolean} $vertical [false] - Is grid vertical or horizontal. Should match grid.\n@mixin exo-cell-block(\n  $vertical: false\n) {\n  $property: if($vertical == true, 'overflow-y', 'overflow-x');\n\n  @if $vertical == true {\n    overflow-y: auto;\n    max-height: 100%;\n    min-height: 100%;\n  } @else {\n    overflow-x: auto;\n    max-width: 100%;\n  }\n\n  -webkit-overflow-scrolling: touch;\n  -ms-overflow-style: -ms-autohiding-scrollbar;\n}\n\n/// Container for inside a grid frame containing multiple blocks. Typically used\n/// as a modifier for a `.cell` to allow the cell to pass along flex sizing\n/// constraints / from parents to children.\n@mixin exo-cell-block-container() {\n  display: flex;\n  flex-direction: column;\n  max-height: 100%;\n\n  > .grid-x {\n    max-height: 100%;\n    flex-wrap: nowrap;\n  }\n}\n\n/////////////////////\n// Exo Grid - Position\n// ---------\n/// Offsets a column to the right/bottom by `$n` columns.\n///\n/// @param {Number|List} $n - Size to offset by. You can pass in any value accepted by the `exo-cell()` mixin, such as `6`, `50%`, or `1 of 2`.\n/// @param {Number|Map} $gutters [$grid-margin-gutters] Map of gutters or single value to use for responsive gutters.\n/// @param {Keyword} $gutter-type [margin] The type of gutter to use. Can be `margin` or `padding`\n/// @param {Number|Array|Keyword} $breakpoint [$-exo-zero-breakpoint] - Single value, breakpoint name, or list of breakpoint names to use for `$gutters`. See `-exo-breakpoint-value()`.\n/// @param {Boolean} $vertical [false] Sets the direction of the offset. If set to true will apply margin-top instead.\n@mixin exo-cell-offset(\n  $n,\n  $gutters: $grid-margin-gutters,\n  $gutter-type: margin,\n  $breakpoint: $-exo-zero-breakpoint,\n  $vertical: false\n) {\n  $direction: if($vertical, 'top', $global-left);\n\n  @include -exo-breakpoint-value($breakpoint, $gutters) {\n    $gutter: rem-calc($-exo-bp-value) * 0.5;\n    $gutter-margin: if($gutter-type == 'margin', $gutter, 0);\n    $size: if($gutter-margin == 0, #{exo-cell-size($n)}, calc(#{exo-cell-size($n)} + #{$gutter-margin}));\n\n    margin-#{$direction}: #{$size};\n  }\n}\n\n/////////////////////\n// Exo Grid - Layout\n// ---------\n/// Sizes child elements so that `$n` number of items appear on each row.\n///\n/// @param {Number} $n - Number of elements to display per row.\n/// @param {String} $selector ['.cell'] - Selector(s) to use for child elements.\n/// @param {Boolean} $gutter-output [true] - Whether or not to output gutters\n/// @param {Number|Map} $gutters [$grid-margin-gutters] - Map or single value for gutters.\n/// @param {Keyword} $gutter-type [margin] - Type of gutter to output. Accepts `margin` or `padding`.\n/// @param {List} $gutter-position [right left] - The position to apply gutters to. Accepts `top`, `bottom`, `left`, `right` in any combination.\n/// @param {String} $breakpoint [null] - The breakpoint to use for the cell generation.\n/// @param {Boolean} $vertical [false] - Set to true to output vertical (height) styles rather than widths.\n@mixin exo-grid-layout(\n  $n,\n  $selector: '.cell',\n  $gutter-output: true,\n  $gutters: $grid-margin-gutters,\n  $gutter-type: margin,\n  $gutter-position: right left,\n  $breakpoint: null,\n  $vertical: false\n) {\n  $size: percentage(math.div(1, $n));\n\n  & > #{$selector} {\n    @include exo-cell($size, $gutter-output, $gutters, $gutter-type, $gutter-position, $breakpoint, $vertical);\n  }\n}\n\n/////////////////////\n// Exo Grid - Collapse\n// ---------\n/// Collapses the grid a cells within it.\n///\n/// @param {String} $selector [.cell] - The child element to remove the gutter from.\n/// @param {Keyword} $gutter-type [margin] - The type of gutter to remove.\n/// @param {List} $gutter-position [right left] - The positions to remove gutters from. Accepts `top`, `bottom`, `left`, `right` in any combination.\n/// @param {Keyword} $min-breakpoint [$-exo-zero-breakpoint] - Minimum breakpoint in `$breakpoint-classes` for which to collapse the gutter.\n@mixin exo-grid-collapse(\n  $selector: '.cell',\n  $gutter-type: margin,\n  $gutter-position: right left,\n  $min-breakpoint: $-exo-zero-breakpoint\n) {\n  // First, lets negate any margins on the top level\n  @if ($gutter-type == 'margin') {\n\n    @include breakpoint($min-breakpoint) {\n      @each $value in $gutter-position {\n        margin-#{$value}: 0;\n      }\n\n      > #{$selector} {\n        @each $value in $gutter-position {\n          margin-#{$value}: 0;\n        }\n      }\n    }\n\n    $excluded-bps: -exo-breakpoints-less-than($min-breakpoint);\n\n    // Output new widths to not include gutters\n    @each $bp in $breakpoint-classes {\n      @if(sl-contain($excluded-bps, $bp)) {\n        @include breakpoint($min-breakpoint) {\n          @for $i from 1 through $grid-columns {\n            // Sizing (percentage)\n            > .#{$bp}-#{$i} {\n              @include exo-cell-static($i, $gutter-output: false, $gutter-type: padding);\n            }\n          }\n        }\n      } @else {\n        @include breakpoint($bp) {\n          @for $i from 1 through $grid-columns {\n            // Sizing (percentage)\n            > .#{$bp}-#{$i} {\n              @include exo-cell-static($i, $gutter-output: false, $gutter-type: padding);\n            }\n          }\n        }\n      }\n    }\n  }\n  @else {\n\n    @include breakpoint($min-breakpoint) {\n      @each $value in $gutter-position {\n        margin-#{$value}: 0;\n      }\n\n      > #{$selector} {\n        @each $value in $gutter-position {\n          padding-#{$value}: 0;\n        }\n      }\n    }\n  }\n}\n\n/////////////////////\n// Exo Grid - Classes\n// ---------\n// Not sure that these are needed or not yet for our use case.\n","@use \"sass:math\";\n@import './unit';\n\n////\n/// @group breakpoints\n////\n\n/// A list of named breakpoints. You can use these with the `breakpoint()` mixin to quickly create media queries.\n/// @type Map\n$breakpoints: (\n  small: 0, // converted from \"0\"\n  medium: 40em, // converted from \"all and (min-width: 40em)\"\n  large: 64em, // converted from \"all and (min-width: 64em)\"\n  xlarge: 120em, // converted from \"all and (min-width: 120em)\"\n) !default;\n\n/// The largest named breakpoint in which to include print as a media type\n/// @type Keyword\n$print-breakpoint: large !default;\n\n$-exo-zero-breakpoint: small !default;\n\n$-exo-breakpoints-keys: map-to-list($breakpoints, 'keys');\n\n@if nth(map-values($breakpoints), 1) != 0 {\n  @error 'Your smallest breakpoint (defined in $breakpoints) must be set to \"0\".';\n}\n@else {\n  $-exo-zero-breakpoint: nth(map-keys($breakpoints), 1);\n}\n\n/// All of the names in this list will be output as classes in your CSS, like `.small-12`, `.medium-6`, and so on. Each value in this list must also be in the `$breakpoints` map.\n/// @type List\n$breakpoint-classes: (small medium large) !default;\n\n/// Generates a media query string matching the input value. Refer to the documentation for the `breakpoint()` mixin to see what the possible inputs are.\n///\n/// @param {Keyword|Number} $val [small] - Breakpoint name, or px, rem, or em value to process.\n@function breakpoint($val: $-exo-zero-breakpoint) {\n  // Size or keyword\n  $bp: nth($val, 1);\n  // Value for max-width media queries\n  $bp-max: 0;\n  // Direction of media query (up, down, or only)\n  $dir: if(length($val) > 1, nth($val, 2), up);\n  // Eventual output\n  $str: '';\n  // Is it a named media query?\n  $named: false;\n\n  // Orientation media queries have a unique syntax\n  @if $bp == 'landscape' or $bp == 'portrait' {\n    @return '(orientation: #{$bp})';\n  }\n  @else if $bp == 'retina' {\n    @return '(-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi)';\n  }\n\n  // Try to pull a named breakpoint out of the $breakpoints map\n  @if type-of($bp) == 'string' {\n    @if map-has-key($breakpoints, $bp) {\n      @if $dir == 'only' or $dir == 'down' {\n        $bp-max: -exo-map-next($breakpoints, $bp);\n      }\n\n      $bp: map-get($breakpoints, $bp);\n      $named: true;\n    }\n    @else {\n      $bp: 0;\n      @warn 'breakpoint(): \"#{$val}\" is not defined in your $breakpoints setting.';\n    }\n  }\n\n  // Convert any pixel, rem, or unitless value to em\n  $bp: -exo-bp-to-em($bp);\n  @if $bp-max {\n    $bp-max: -exo-bp-to-em($bp-max) - math.div(1, 16);\n  }\n\n  // Conditions to skip media query creation\n  // - It's a named breakpoint that resolved to \"0 down\" or \"0 up\"\n  // - It's a numeric breakpoint that resolved to \"0 \" + anything\n  @if $bp > 0em or $dir == 'only' or $dir == 'down' {\n    // `only` ranges use the format `(min-width: n) and (max-width: n)`\n    @if $dir == 'only' {\n      // Only named media queries can have an \"only\" range\n      @if $named == true {\n        // Only use \"min-width\" if the floor is greater than 0\n        @if $bp > 0em {\n          $str: $str + '(min-width: #{$bp})';\n\n          // Only add \"and\" to the media query if there's a ceiling\n          @if $bp-max != null {\n            $str: $str + ' and ';\n          }\n        }\n\n        // Only use \"max-width\" if there's a ceiling\n        @if $bp-max != null {\n          $str: $str + '(max-width: #{$bp-max})';\n        }\n      }\n      @else {\n        @warn 'breakpoint(): Only named media queries can have an `only` range.';\n      }\n    }\n\n    // `down` ranges use the format `(max-width: n)`\n    @else if $dir == 'down' {\n      $max: if($named, $bp-max, $bp);\n\n      // Skip media query creation if input value is exactly \"0 down\",\n      // unless the function was called as \"small down\", in which case it's just \"small only\"\n      @if $named or $bp > 0em {\n        @if $max != null {\n          $str: $str + '(max-width: #{$max})';\n        }\n      }\n    }\n\n    // `up` ranges use the format `(min-width: n)`\n    @else if $bp > 0em {\n      $str: $str + '(min-width: #{$bp})';\n    }\n  }\n\n  @return $str;\n}\n\n/// Wraps a media query around the content you put inside the mixin. This mixin accepts a number of values:\n///  - If a string is passed, the mixin will look for it in the `$breakpoints` map, and use a media query there.\n///  - If a pixel value is passed, it will be converted to an em value using `$global-font-size` as the base.\n///  - If a rem value is passed, the unit will be changed to em.\n///  - If an em value is passed, the value will be used as-is.\n///\n/// @param {Keyword|Number} $value - Breakpoint name, or px, rem, or em value to process.\n///\n/// @output If the breakpoint is \"0px and larger\", outputs the content as-is. Otherwise, outputs the content wrapped in a media query.\n@mixin breakpoint($value) {\n  $str: breakpoint($value);\n  $bp: index($-exo-breakpoints-keys, $value);\n  $pbp: index($-exo-breakpoints-keys, $print-breakpoint);\n\n  $old-exo-size: null;\n\n  // Make breakpoint size available as a variable\n  @if global-variable-exists(-exo-size) {\n    $old-exo-size: $-exo-size;\n  }\n  $-exo-size: nth($value, 1) !global; // get the first value to account for `only` and `down` keywords\n\n  // If $str is still an empty string, no media query is needed\n  @if $str == '' {\n    @content;\n  }\n\n  // Otherwise, wrap the content in a media query\n  @else {\n    // For named breakpoints less than or equal to $print-breakpoint, add print to the media types\n    @if $bp != null and $bp <= $pbp {\n      @media print, screen and #{$str} {\n        @content;\n       }\n    }\n    @else {\n      @media screen and #{$str} {\n        @content;\n      }\n    }\n  }\n\n  @if $old-exo-size != null {\n    // Restore the old breakpoint size\n    $-exo-size: $old-exo-size !global;\n  }\n  @else {\n    $-exo-size: null !global;\n  }\n}\n\n/// Convers the breakpoints map to a URL-encoded string, like this: `key1=value1&key2=value2`. The value is then dropped into the CSS for a special `<meta>` tag, which is read by the Foundation JavaScript. This is how we transfer values from Sass to JavaScript, so they can be defined in one place.\n/// @access private\n///\n/// @param {Map} $map - Map to convert.\n///\n/// @returns {String} A string containing the map's contents.\n@function -exo-bp-serialize($map) {\n  $str: '';\n  @each $key, $value in $map {\n    $str: $str + $key + '=' + -exo-bp-to-em($value) + '&';\n  }\n  $str: str-slice($str, 1, -2);\n\n  @return $str;\n}\n\n/// Find the next key in a map.\n/// @access private\n///\n/// @param {Map} $map - Map to traverse.\n/// @param {Mixed} $key - Key to use as a starting point.\n///\n/// @returns {Mixed} The value for the key after `$key`, if `$key` was found. If `$key` was not found, or `$key` was the last value in the map, returns `null`.\n@function -exo-map-next($map, $key) {\n\n  // Store the keys of the map as a list\n  $values: map-keys($map);\n\n  $i: 0;\n\n  // If the Key Exists, Get the index of the key within the map and add 1 to it for the next breakpoint in the map\n  @if (map-has-key($map, $key)) {\n    $i: index($values, $key) + 1;\n  }\n\n  // If the key doesn't exist, or it's the last key in the map, return null\n  @if ($i > length($map) or $i == 0) {\n    @return null;\n  }\n  // Otherwise, return the value\n  @else {\n    @return map-get($map, nth($values, $i));\n  }\n\n}\n\n/// Return a list of our named breakpoints less than $key. Useful for dealing with\n/// responsive gutters for the grid.\n/// @access private\n///\n/// @param {String} $key - Key to use as last breakpoint.\n///\n/// @returns {Array} The list of breakpoints up to and. If $key is auto, returns breakpoints above the zero\n@function -exo-breakpoints-less-than($key) {\n  $list: ();\n  $found-key: false;\n\n  @each $name in $-exo-breakpoints-keys {\n    @if ($name == $key) {\n      $found-key: true;\n    }\n    @if not $found-key {\n      $list: append($list, $name);\n    }\n  }\n  @return $list;\n}\n\n/// Return a list of our named breakpoints less than $key. Useful for dealing with\n/// responsive gutters for the grid.\n/// @access private\n///\n/// @param {String} $breakpoing - a named or non-named breakpoing.\n///\n/// @returns {Array} The list of breakpoints up to and. If $key is auto, returns breakpoints above the zero\n@function -exo-closest-named-breakpoint($breakpoint) {\n  $last: $-exo-zero-breakpoint;\n  $found: false;\n\n  $value: unitless-calc($breakpoint, 1px);\n  @each $key, $val in $breakpoints {\n    @if not $found {\n      @if unitless-calc($val) > $value {\n        $found: true;\n      }\n      @else {\n        $last: $key;\n      }\n    }\n  }\n\n  @return $last;\n}\n\n/// Get a value for a breakpoint from a responsive config map or single value.\n/// - If the config is a single value, return it regardless of `$value`.\n/// - If the config is a map and has the key `$value`, the exact breakpoint value is returned.\n/// - If the config is a map and does *not* have the breakpoint, the value matching the next lowest breakpoint in the config map is returned.\n/// @access private\n///\n/// @param {Number|Map} $map - Responsive config map or single value.\n/// @param {Keyword} $value - Breakpoint name to use.\n///\n/// @return {Mixed} The corresponding breakpoint value.\n@function -exo-get-bp-val($map, $value) {\n  // If the given map is a single value, return it\n  @if type-of($map) == 'number' {\n    @return $map;\n  }\n\n  // Check if the breakpoint name exists globally\n  @if not map-has-key($breakpoints, $value) {\n    @if type-of($value) == 'number' {\n      $value: -exo-closest-named-breakpoint($value);\n    }\n    @else {\n      @return null;\n    }\n  }\n  // Check if the breakpoint name exists in the local config map\n  @else if map-has-key($map, $value) {\n    // If it does, just return the value\n    @return map-get($map, $value);\n  }\n  // Otherwise, find the next lowest breakpoint and return that value\n  @else {\n    $anchor: null;\n    $found: false;\n\n    @each $key, $val in $breakpoints {\n      @if not $found {\n        @if map-has-key($map, $key) {\n          $anchor: $key;\n        }\n        @if $key == $value {\n          $found: true;\n        }\n      }\n    }\n\n    @return map-get($map, $anchor);\n  }\n}\n\n/// Return the best breakpoint to use according to the calling context. It returns in order:\n/// 1. the given `$value` argument if it is not null.\n/// 2. the global breakpoint context `$-zf-size` if it is not null (like if called inside then `breakpoint()` mixin)\n/// 3. the given `$default` argument.\n/// @access private\n///\n/// @param {Keyword} $value [null] - Breakpoint to use in priority if non-null.\n/// @param {Keyword} $default [null] - Breakpoint to use by default if no other value can be used.\n///\n/// @return {Keyword} The resolved breakpoint.\n@function -exo-current-breakpoint($value: null, $default: null) {\n  @if ($value != null) {\n    @return $value;\n  }\n  @else if (variable-exists(-exo-size) and type-of($-exo-size) != 'number') and $-exo-size != null {\n    @return $-exo-size;\n  }\n  @else {\n    @return $default;\n  }\n}\n\n@if map-has-key($breakpoints, small) {\n  $small-up: screen;\n  $small-only: unquote('screen and #{breakpoint(small only)}');\n}\n\n@if map-has-key($breakpoints, medium) {\n  $medium-up: unquote('screen and #{breakpoint(medium)}');\n  $medium-only: unquote('screen and #{breakpoint(medium only)}');\n}\n\n@if map-has-key($breakpoints, large) {\n  $large-up: unquote('screen and #{breakpoint(large)}');\n  $large-only: unquote('screen and #{breakpoint(large only)}');\n}\n\n@if map-has-key($breakpoints, xlarge) {\n  $xlarge-up: unquote('screen and #{breakpoint(xlarge)}');\n  $xlarge-only: unquote('screen and #{breakpoint(xlarge only)}');\n}\n\n@if map-has-key($breakpoints, xxlarge) {\n  $xxlarge-up: unquote('screen and #{breakpoint(xxlarge)}');\n}\n"]}